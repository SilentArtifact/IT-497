\documentclass{article}
\usepackage{hyperref}

\usepackage{color}
\usepackage{xcolor}
\usepackage{listings}

\usepackage{caption}
\DeclareCaptionFont{white}{\color{white}}
\DeclareCaptionFormat{listing}{\colorbox{gray}{\parbox{\textwidth}{#1#2#3}}}
\lstset{ 
  breaklines=true
}
\captionsetup[lstlisting]{format=listing,labelfont=white,textfont=white}

\usepackage{Sweave}
\begin{document}
\input{OSEMN-concordance}
\lstset{breaklines=true} % break long lines
\begin{Schunk}
\begin{Sinput}
> library(knitr)
> render_listings()
\end{Sinput}
\end{Schunk}

\title{Rotten Tomatoes API}
\date{April 15th, 2015}
\author{Matthew Gromer}
\maketitle

\section*{Introduction}
Rotten Tomatoes is one of the largest and most well-regarded film review sites online, with only one other major challenger, Metacritic. Rotten Tomatoes reviews film with their own unique rating scale, "Fresh", represented by a ripe, red tomato, for good films, and "rotten", a green, splat-mark, for poor films. It garners nearly 26,000,000 unique page-views a month, and is one of the top 250 U.S. websites. 
It hosts a glut of data on films, actors, critics, as well as having trailers and local theater information.

Rotten Tomatoes, like many other websites, has offered their film information to the general public via their open API. This tutorial will walk you through the process of obtaining access to this API and using it, in this case to determine the average ratings of G- and R-rated current films. Movies in the US all have guidance ratings, put in place using the Motion Picture Association of America's own system. This system rates a film on a scale, starting with "G", General Audiences, to "PG", Parental Guidance Suggested, to "PG-13", Parents Strongly Cautioned, to "R", Restricted, and ending with "NC-17", Adults Only. 

These ratings are given based on the content of the film, as well as general plot and theme; films that are graphically violent, or sexual will be placed much higher on the scale than those that make efforts to reduce harsh visuals. Films that work to create a great sense of fear or terror will also find themselves placed higher on the scale, to warn parents against allowing younger children to view them.

\section*{Getting Access to the API}
Like many sites that offer an API, Rotten Tomatoes requires a new prospective user to register with them first. To do this, you will need to visit \href{http://developer.rottentomatoes.com/member/register}{the API registration page}, and provide some information, specifically, your information, what you intend to use the API for, and how much use you expect it to get. Rotten Tomatoes gathers this information so that they can determine how much load your API key might add to their service. Once you've completed registration, you'll be sent a confirmation email. Once the link within is accepted, you'll be emailed an API key. An API key, or application programming interface key, is a unique string of characters that's used by a program or interface to identify who or what is calling on it for information. With this key, Rotten Tomatoes' interface will provide you with the information that you ask for. For this example, our key is as follows:
\begin{lstlisting}[label=APIKey,caption=API Key]
  pv8e8c9wkgkuwpsbpk72b8tg
\end{lstlisting}
We'll use this key in every interaction with the Rotten Tomatoes API. Make a note of your key, and do not lose it!

\section*{Obtaining the Data}
Once you've aquired an API key, you can use it, along with a bit of R code, to obtain the information you're looking for. The Rotten Tomatoes API will, unfortunately, only provide 50 "pages" of information, which generally means 50 films/TV shows from a given query. To make a query using R, you'll need to use the R package "jsonlite", and the command "fromJSON". 

The API documentation details several calls that can be made of their API, each pulling specific information, and each with various parameters that can be used to customize the call. For example, if you wanted to pull any information Rotten Tomatoes had on Toy Story 3, you would use the following API call:
\begin{lstlisting}[label=ToyStory3Info,caption=API Call]
  http://api.rottentomatoes.com/api/public/v1.0/movies/770672122.json?apikey=
\end{lstlisting}
When the API key is added to this call, it completes it, creating this:
\begin{lstlisting}[label=ToyStory3Info,caption=API Request]
  http://api.rottentomatoes.com/api/public/v1.0/movies/770672122.json?apikey=pv8e8c9wkgkuwpsbpk72b8tg
\end{lstlisting}
In the case of our example, we want to pull the ratings of movies that are currently out, alongside their MPAA ratings. To do this, we'll use the "DVD Current Releases" request.

\begin{Schunk}
\begin{Sinput}
> # Code Chunk 1: Aquire Data
> library(jsonlite)
> library (plyr)
> # We can see here the complete API call, with our API key entered in. This will grab 
> URL <-"http://api.rottentomatoes.com/api/public/v1.0/movies.json?&apikey=pv8e8c9wkgkuwpsbpk72b8tg&q=a&page_limit=50&page=1"
> # This if statement exists to keep from needlessly running, if it's been run before.
> if(!file.exists("rotten.csv")){
+   for (i in  1:20){
+     # This is the actual API call.
+     URLpage <-paste0(URL, i)
+     l = jsonlite::fromJSON(URLpage)
+     df <-as.data.frame(l)
+     
+     # At this point, we go through the set of 50 records, and take specifically what we want.
+     t<-df$movies.title
+     x<-df$movies.mpaa_rating
+     y<-df$movies.ratings$audience_score
+     z<-df$movies.ratings$critics_score
+     df.xyz = data.frame(t, x, y, z)
+   
+     # Here, we package the first set of data, and bind it to the complete dataset.
+     if (i == 1){
+       data <- df.xyz
+     }else{
+       data <- rbind(data, df.xyz)
+     }
+     
+     # Here, we export the dataset to a file, and append subsequent sets of data.
+     write.table(df.xyz, file="rotten.csv", col.names=F, row.names=F, append=T, sep=",")
+     Sys.sleep(2) 
+   }
+   colnames(data) <- c("Title","MPAA_Rating","Audience_Score","Critics_Score")
+ }
> 
\end{Sinput}
\end{Schunk}
\emph{Code Chunk 1: Aquiring Data using fromJSON}

This gets us the data we need, in a nice and tidy data frame format. In this example, we grabbed title as well as the necessary data, to show what's involved in scrubbing the data.

\section*{Scrubbing the Data}
Now that we've got our data, we'll "scrub" it; scrubbing is a term for parsing, or formatting the raw data so that it becomes useful to our purposes. In this case, we want to obtain three specific variables from the data: the MPAA rating, the critics' score, and finally, the audiences' score. These three variables will let us group films by rating, and then determine how both critics and audiences rated them. In R, this is done through subsetting (a.k.a. taking a "subset" of the data.)

\begin{Schunk}
\begin{Sinput}
> # Code Chunk 2: Begin Cleaning
> 
> # We select the specific columns that we want, and remove the rest.
> wantedVariables <- c("MPAA_Rating","Audience_Score","Critics_Score")
> cleanedData <- data[wantedVariables]